正则表达式：
    使用目的：对字符串格式的校验。

re模块使用：
    re.match()：
        #使用macth匹配，匹配成功返回匹配对象(Match Object),否则返回None（不是空字符串“”，因为空字符串也是匹配对象）
        #match匹配到正确的字符串后，就不会继续匹配后面的字符串。同样，第一个不符合匹配，则后面也不再继续匹配。
        result = re.match(正则表达式，要匹配的字符串) 
        #匹配到数据，可group方法提取
        result.group(组号) 
     
    re.search()：
        使用match时，第一个字符不匹配就不再继续。
        使用search时，第一个字符不匹配就继续匹配下去，匹配成功就不再匹配下去。
        
    re.findall():
        使用findall，会把所有符合调条件的字符都匹配出来。
        findall()返回的是一个list，而match和search都是返回对象object，因此findall()没有group方法。只用能[]查询。
        
    re.sub():
        将匹配到的数据进行替换。sub = findall匹配+替换
        re.sub(r"正则匹配规则","替换的字符","待匹配的字符串s")
    
    re.split():
        根据匹配进行切割字符串，并返回一个列表。
                      
    
表示字符：
    .   -->匹配任意一个字符（除了\n），（所以点号是正则表达式的特俗字符，要匹配点号需要转义\)
    []  -->匹配[]中列举的字符      
    \d  -->数字0-9     
    \D  -->非数字
    \s  -->匹配空白，即 空格，tab键
    \S  -->匹配非空白
    \w  -->匹配单词字符，即a-z、A-Z、0-9、_
    \W  -->匹配非单词字符
    
    等价
    \d == [0-9]
    \D == [^0-9]    
    \w == [a-zA-Z0-9_]
    \W == [^a-zA-Z0-9_]    
    
表示数量：
    *   -->[0,∞ )
    +   -->[1,∞ )
    ?   -->[0,1]
    {m} -->[m]
    {m,} -->[m,∞ )
    {m,n} -->[m,n]
    
原始字符串：
    对\n转义 --> \\n
    对\\n转义 --> \\\\n  
   
    综上，用反斜杠转义很麻烦，python里用字母r就可表示原始字符：
    re.match("\\n",s) == re.match(r"\n",s)
        
表示边界：
    ^   -->匹配字符串开头，在[]里则表示取反。（若第一个字符不匹配，全都不匹配）
    $   -->匹配字符串结尾（若字符串最后一个不匹配，则不匹配）
    \b  -->匹配一个单词的边界,即出现空格
    \B  -->匹配非单词边界，即出现单词
    
    例子：re.match(r"^1[35678]\d{9}$",s)  手机号的正则表达式
    
匹配分组：
    |   -->匹配左右任意一个表达式，即或逻辑
        例子1：re.match(r"0$|[1-9]{1,2}$|100$",s)    匹配0-100
        
    (ab) -->将括号中字符作为一个分组，多个分组匹配成功后，就可以用group查看了
        例子2：result = re.match(r"(<h1>).*(</h1>)","<h1>网页</h1>")
              result.group(1) #查看<h1>
        
    \num    -->引用分组匹配到的字符串
        例子3：s = <html><h1> my str </h1></html>
              re.match(r"<(.+)><(.+)>.+</\2></\1>",s) #\2和\1表示提取分组2和1的内容
            
    (?p<name>)  -->分组起别名
        例子4：s = <html><h1> my str </h1></html>
              re.match(r"<(?p<key1>.+)><(?p<key2>.+)>.+</(?P=key2)></(?P=key1)>",s) 
    (?P=name)   -->引用别名为name分组匹配到的字符串
        见例4
贪婪和非贪婪：
    贪婪：正则表达式的默认是贪婪模式的，贪婪模式就是一直往下找，尽量匹配尽可能多的字符。 
    非贪婪：与贪婪相反，总是尝试匹配尽可能少的字符。
    
    关闭贪婪：
        在表示数量的符号： *、？、+、{m,n}后面加上？就变成非贪婪。
        例子：
            re.match(r"aa(\d+)","aa1234zz").group(1)     #贪婪，返回1234。
            re.match(r"aa(\d+?)","aa1234zz").group(1)    #非贪婪，返回1。
        
           














    
