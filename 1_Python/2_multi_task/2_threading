多线程-threading：
	Python的threading模块实现了多线程，利用多线程使得快速完成一个任务。多线程和多进程都是实现多任务的方法。
	
	进程是资源（内存等）分配的单位，线程是cpu调度的单位。可以想象每个进程里都有一个箭头(线程)，用于指向代码的执行，单进程里实现了多线程，
		相当于开了多个箭头。同样，多线程和多进程类似，拥有一个主线程。操作系统正真调度的是线程。
	
	多线程里，主线程执行完了也会等待子线程执行完才退出（类似多进程)。多个线程执行同一个函数，各自之间不会有影响。在多进程里，主进程会等待子进程结
		束才结束，是为了收回子进程的内存资源：如果子进程死了却没有被主进程收回，这样的子进程就叫僵尸进程；主进程先死了，这样的子进程叫孤儿进程。
	
	多线程的执行顺序：
		由操作系统调度，不确定。
	
	线程共享全局变量：与多进程不同的是，多线程对全局变量的修改会影响到其他线程对全局变量的使用。全局变量用得不好容易导致出错，即线程不安全。
	
Thread：
	和Process类似，创建多线程也有两种方法：
	方法1：
		from threading import Thread
		t = Thread(targrt=xxx)
		t.start() 
		【注：这里与多进程不同：多进程想同时执行生成的多个进程，必须用for同时生成。而多线程在这里相当于创建了多个“箭头”，不用for也会同时进行。】
	
	方法2：
		继承Thread子类：
			和Process子类一样，定义自己写的类继承Thread，改写run方法，p.start()会调用run方法
			创建一个线程，默认名字self.name就叫Thread-1，以此类推。
	
避免全局变量被修改(线程同步)：
	1.轮询，设置一个标志位，等条件满足再执行修改全局变量。效率不高，因为一直都在while True里面判断标志位。
	2.（通知）互斥锁threading.Lock()，使用的唯一目的是为了在多个线程使用同一个资源而产生竞争的时候上锁，解决共享资源而不出现问题。
		
		mutex = Lock() #创建一把锁,默认是没有上锁的。
		mutex.acquire(block=True,timeout=-1) #上锁，通知其他方我方已上锁，别再竞争。默认是堵塞的，程序执行到此会等待解锁才继续执行，-1代表永久。
		---产生竞争的代码----
		mutex.release()	#解锁，通知其他方我方锁已解，这样避免了轮询的低效率。
		注：上锁的代码区间应尽量小，使线程尽量并发。
	
	
多线程使用非共享变量：
	即使多个线程执行的是同一个函数，各个线程的变量都是独有的，即每个线程的函数都有独立的空间，除了全局变量是共享的。因此，对于非共享变量不用加锁。
	
死锁：
	概念：线程间共享个多资源时，线程之间分别占用一部份资源并且等待对方的资源，就会造成死锁。
	避免死锁：
		1.添加超时时间：mutex.acquire()的timeout添加时间
		2.程序设计避免：如银行家算法（评估安全了才选择分配对象）
	 
同步和异步：
	同步：就是协同步调，按预定的先后次序（队列）进行运行。使线程同步的手段有：轮询和互斥锁(通知),同步是堵塞（队列）的。
	异步：程序协同合作，异步是非堵塞的。	
	
	同步的应用：
		多个线程有序执行：利用互斥锁，让未上锁的线程给上锁的线程开锁，环环相扣实现有序执行。
	
	异步的实现：
		在多进程中，Pool创建的进程，apply_async(func=xxx)就是非堵塞的，在apply_async添加参数callback=xx，构成回调函数。
		pool.apply_sync(func=test1,callback=test2) 即主进程在执行任务，子进程完成了test1构成触发callback，主进程放下当前任务去执行tes2，
		这就是异步。
			

生产者和消费者模式：
	多任务的情况下，数据生产方和数据处理方的速度不匹配，”生产者和消费者模式“是解决这一类问题的思路。解决速度不匹配的问题有一个好处：解耦(耦合），
	耦合性越强程序越不好（程序相关性太强，就像一团毛线会很乱，不利于更改和升级，最坏的结果就是程序得重构)。
		
	解决办法：在中间添加缓冲区(或管道)，如利用：队列(Queue)。(队列是先进先出，所以队列是阻塞的),阻塞队列往往就是用来给生产者和消费者解耦的。
			生产者和消费者模式的本质就是用了进程间通信或其他通信，解决了进程间的数据沟通
			
		Queue:
			multiprocessing模块有个Queue()用于进程间通信，queue有个Queue()用于线程间通信，两者不能替换使用,注意区分。
			无论是多线程还是多进程，只要是生产和消费者问题，都可以用队列解决。
	
ThreadLocal:
	全局字典：
		函数想使用另一个函数的数据有两种方式，1是传递参数，2是使用全局变量。在多线程里使用全局变量是不安全的--即对全局变量的修改会影响其他线程对这个
		全局变量的使用，但是在函数里调用函数传递参数又显得枯燥，有个更好的方式是使用”全局字典“。
		
	import threading:
		使用全局字典可以解决函数对函数传参问题，但还是有些费劲。threading.local()类创建的全局变量，能够识别不同的线程，因此虽然是全局变量，但
		不同的线程对其修改，并不会影响其他线程对该全局变量的使用。
	
GIL全局解释器锁：
	在多线程里，如果计算机cpu是多核的，那么一个线程会占用一个核，即并发。由于历史原因，Python的多线程是假的，只能使用一个核，原因是GIL。
	如果想在python里实现多任务的并发，可以使用多进程，Python的多进程无锁，因此效率比多线程高。
	
	解决GIL：用c语言来解决
		c语言的库：我想你用我的功能但不想暴露源码，就可以把源码编译成二进制文件。
			静态库：所有的文件都已直接编译好。
			动态库：有可能很多东西依赖当前的系统。
			
		首先把一个C语言文件（如：test.c)编译成一个动态库，命令：gcc test.c -shared -o libtest.so ,生成libtest.so文件
		在python文件里加载动态库，需要用到ctypes标准库：
			from threading import Thread
			from ctypes import *
			lib = cdll.LoadLibrary("./libtest.so") # 加载本地的c动态库，cdll为ctypes里的功能。
			t.Thread(target=lib.DeadLoop) # 假设DeadLoop为libtest.so里的一个c函数，功能为死循环,由子线程执行
			t.start()
			# 主线程执行另一个死循环，这样，整个进程一共有两个线程执行两个死循环，cpu的两个核会被占满，从而实现并发。
			while True:
				pass
			
		
	
	 
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
