0.关于三个引号"""：
    python的注释是#号，python解释器会自动忽略有#的代码。有时候使用"""也可以当做多行注释，
    但"""并不是注释符，它对python解释器依旧是有意义的，会被执行的，
    """的真正作用是：保留字符串的原始格式，不因字符串里面的引号、换行的影响。
    
1.缺省参数的定义
	def test(a,b=22):   -->缺省参数必须放在后面，如果是def test(b=22,a) 则会报错
2.*args 
	在一个函数里传入多个参数可用*args，代表这是一个元组，另外，元组里只有一个参数时必须带有逗号才算是元组，如：（3，）
	而且*args必须放在形参的最后面，如def test(*args,a) 则调用函数时无法把参数传入给a
3.拆包（元组、字典）
	在函数调用参数传递时，当A=（1,2），K={'value':123} 可用test(a,b,*A,**k)传入

4. 可变与不可变类型
	在Python中，赋值其实是一种对数据的引用，而Python的数据可分为可变和不可变类型。
	【不可变数据类型】共3种：int(数字） , str（字符串） ,tuple（元组）
	【可变数据类型】共2种 ： list ， dict 		
	 dict(字典）：在Python的dict中，key必须是不可变类型,否则会报unhashable type错误，可变类型不适合做哈希，因为一旦值改变了，哈希值就变了
	 
5. 递归
	递归和函数嵌套类似，不同的是递归是调用自身，递归要注意的问题是程序必须有一个结束出口，否则就像一个死循环会导致内存溢出。
	递归使用栈保存当前的环境变量
	
6.匿名函数
应用：
	1、对list排序可用sort方法，但如果list里面有dict或str等非数字类型数据就不能单纯的sort排序，可用list.sort(key= lambda:x['name'])
		key参数接收排序的关键字，我们用lambda指定排序类型的关键字。
	2.用匿名函数当实参 --> def test(a ,b ,lambda x,y:x+y)
	3.eval()函数的使用，如 resutl = input("lambda x,y:x+y")      func = eval(result) ,eval()会把字符串“变成”函数。
	
7.可变与不可变的扩充

	对于不可变类型：sum = sum+sum 和sum+=sum是等价的
	对于可变类型 ： sum = sum+sum 和 sum+=sum是不等价的
	
8.面向对象(三个要素：封装(全局变量和函数）、继承（子-->父）、多态（定义的时候不确定调用什么功能，真正调用的时才确定调用的是子类还是父类的功能) 


	类名+()， 等于创建了一个新的对象，对象会自动调用__init__(self)方法，self引用对象因此可以进行对对象的属性进行参数传递
	
	__str__()方法用于获取执行的对象的描述信息，也是Python自动调用的,必须用return返回。如test = Test(1,2)  print(test) 
			实际上是打印__str__的返回值。
			
	私有方法：_ _xxx(self): 在对象外部无法使用，用能通过调用公有方法来调用私有方法
	
	__del__(self)方法:	Python里一切赋值皆引用，若该方法在类中定义了，当该类的引用计数为0则会执行该方法，否则不执行。
	
	测量引用计数：sys.getrefcount(类),测量的结果比实际个数大1
	
9.面向对象2
	重写：子类和父类的方法相同，则子类方法会覆盖父类方法。
	调用重写的父类方法：
		第一种方式： 父类.方法(self)     self是必须有的
		第二种方式： super().方法()		不需要self
	父类的私有方法和私有属性都不会被子类继承
	多继承： class mutil(A,B,C)
	类属性和实例属性：
		在Python里一切都是对象，即便对象是由类创建的，类实际也是一种对象，称为“类对象”，而由类创建的对象称为“实例对象”。
		类属性：	
			定义在class内的不带self的变量，称为类属性，类属性在实例对象之间共享，类似全局变量。
		实例属性：
			比如self.name就是一个实例属性，实例属性在实例对象之间是不共享的，每次创建实例对象时会为实例属性开辟独立的内存空间，
			而类属性只有一个内存空间，实例对象都是靠引用来访问类属性。
	类方法@classmethod:
		为了对类属性进行修改，在实例方法前使用@classmethod装饰器，则该方法就变成了类方法，一般类方法的接入参数不是self而是cls。
	静态方法@staticmethod：
		实例方法前加上@staticmethod,并且把传入的参数self去掉（ 可有可无）就成了静态方法，静态方法一般是为了添加与类和实例对象都无关的功能
		
	__new__(cls)方法： 对象的创建是使用该类方法，__init__(self)中的self指向对象的引用，init方法用于初始化，而self中的值来自于
						new方法的return返回值，若重写了new方法必须return父类的new方法，否则无法创建对象。所有的对象的new
						方法均继承自object.__new__(cls)
	创建单例对象	：即使是同一个类创建的多个对象，都是指向不同的内存空间，即对象是相互独立存在的，仿佛是类的深拷贝。所谓单例对象，
		就是无论创建多少对象，内存空间都指向同一个内存地址，仿佛浅拷贝。使用__new__(cls)方法的目的是创建单例对象 

10.异常处理
	try ...except:	把可能出错的代码写到try里，except写出现错误的处理手段，Exception是所有异常的总称，它能捕获所有异常。
	finary ：不管程序有没有出现异常，程序都会执行finary语句
	异常传递、
	抛出自定义异常：raise 自定的异常类，所有自定义的异常类均继承自Exception
	
11.模块
	__name__ == '__main__':	导入一个模块实际上会执行整个模块的代码，如果只想模块被导入而不执行，把要执行的函数放在if __name__=='__main__' 之后。
	
	__all__ = [] 作用：在该模块里声明all变量，添加只想被import的函数或类，当import该模块的时候只会导入all指定的函数或类。若all变量在__init__.py
					文件中声明，则指定包里面导入那些模块。
	给程序传参：sys.argv  ,程序运行的时候，根据给定不同的参数从而运行不同的命令，如pip install xxx,pip remove xxx,都是pip这个程序。
	
12.集合set
	集合用{}表示，如{1,2,3}
	去重  a = [ 1,1,2,3,4,3]  f = set(a)
	
	
	









	

